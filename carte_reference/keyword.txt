- var : permet de déclarer une variable var [nom_variable] [type_variable]
ex : 
var a int = 1
ou direct 
a := 1

//METTRE TABLEAU
# [] : permet de déclarer un tableau ou une slice (tableau dynamique)
var b [2] int
b[0]=0
b[1]=1
ou direct 
 b := [2]int{0, 1}
 
# len : permet de récupérer la taille d'un tableau ou d'une slice
 var a [2] int
fmt.Println(len(a))
 

METTRE SLICE
# make : permet de déclarer une slice (tableau dynamique) à une ou plusieurs dimensions
s := make([]string, 2)
s[0] = "a"
s[1] = "b"
ou direct 
s := []string{"a", "b"}
 
# append : permet d'ajouter un élément dans une slice 
s := make([]string, 2)
	s[0] = "a"
    s[1] = "b"
    s = append(s, "c") 
    
# copy : permet de copier une slice dans une autre 
s := make([]string, 2)
	s[0] = "a"
    s[1] = "b"
c := make([]string, len(s))
    copy(c, s);
    
- MAP : permet de stocker des valeurs en leur associant une clé make(map[key_type] val_type).
m := make(map[string]int)
 m["mehdi"] = 1
 m["clement"] = 2
 
- delete : permet de supprimer une valeur dans la map
m := make(map[string]int)
 m["mehdi"] = 1
 m["clement"] = 2
 delete(m, "clement")
 
- identificateur "_" : permet de déclarer une variable permettant de tester la présence d'une clé (true ou false)
m := make(map[string]int)
 m["mehdi"] = 1
 m["clement"] = 2
 _, test := m["clement"]
 
- range : permet d'itérer facilement dans une structure de tableau, de slicee ou de map
tab := []int{1, 2, 3}
    somme := 0
    for _, val := range tab {
        somme += val
    }
    fmt.Println("Somme:", somme)
    
- func : permet de déclarer une fonction et peut avoir plusieurs retours : func function_name( [parameter list] ) [return_types]
func calcul (val1 int, val2 int) int {
	return val1 + val2
}

func calcul2 (val1 int, val2 int) (int, int){
	return val1 + val2, val1 - val2
}
func main() {
	var test1, test2, test3 int = 0, 0, 0
	test1, test2 = calcul2(2,3)
	test3 = calcul3(1,2)
}

# pointeur : permet de faire des références sur des variables. Les pointeurs Go s'utilisent comme en langage C
func add (val *int){
	*val = *val + 1
}
func main() {
	var cal int = 2
	add(&cal)
	fmt.Println(cal)
}

- struct : permet de créer un nouveau type de variables possédant plusieurs champs : 
type etudiant struct {
    nom string
    num  int
}

func main() {
	e := etudiant{nom: "Clement", num: 21501810}
    fmt.Println(e)
}

- méthode : correspond à une fonction déclarée pour une structure (hors de la déclaration de la structure)
func (e etudiant) change_num (nouveau int) etudiant{
	e.num=nouveau
	return e
}
func main() {
	e := etudiant{nom: "Clement", num: 21501810}
	e=e.change_num(21500000)
    fmt.Println(e)
}

- interface : permet de regrouper des signatures de méthodes communes à plusieurs structures
type politesse interface {
	saluer() string
}

type francais struct {
	nom string
}

func (f francais) saluer() string {
	return "bonjour"
}

type anglais struct {
	name string
}

func (a anglais) saluer() string{
	return "hello"
}

func parler(p politesse) {
	fmt.Println(p.saluer())
}

func main() {

angl := anglais{name: "James"}
	fran := francais{nom: "Jean"}
	
	parler(angl) // affiche "hello"
	parler(fran) // affiche "bonjour"
}


- const : permet de déclarer une constante (non modifiable) const [nom_constante] [type_variable]
ex : 
const pi double float32 = 3.14

- for : permet de faire une boucle 
ex : 
for i := 0; i < 10; i++ {
	fmt.Println(i)
}

- break : permet de sortir d'une boucle 
ex : 
for i:=0; i < 10; i++ {
	 if i == 5 {
        break
    }
	fmt.Println(i)
}

- switch : permet de faire une succession de cas possibles
ex : 
	i := 1
    switch i%2 {
    case 0:
        fmt.Println("pair")
    case 1:
        fmt.Println("impair")
    }
    
- import : permet d'importer des fichiers tels que les bibliotheques standards (ex : fmt)

import "fmt"
import "math"

- error : permet de gérer des exceptions

func quotient (num float32, denom float32) (float32, error){
	if denom == 0 {
		return -1, errors.New("Erreur mathematique")
	}else {
		return num / denom, nil
	}
}

func main() {
var c1 float32
	var err error
	var a1, b1 float32 = 1,2
	c1,err = quotient(a1, b1)
	fmt.Println(c1)
	fmt.Println(err)
}



